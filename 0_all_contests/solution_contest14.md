# Solution of Contest14
[VJudge链接](https://cn.vjudge.net/contest/168561)\
[CodeForces链接](http://codeforces.com/contest/716)
## #A Crazy Computer
### Description & Solution
给出一串数，按顺序处理每个数，用计数器累计个数，当两个数之间的间隔大于一个给定的数c时，计数器清零。求最后计数器记录的个数。
### Code
```Cpp
ans=0;
lst=0;
scanf("%d%d",&n,&c);
for(int i=1,j;i<=n;i++) {
    scanf("%d",&j);
    if(j-lst>c) ans=0;
    ans+=1;
    lst=j;
}
printf("%d\n",ans);
```
***
## #B Complete the Word
### Description
输入一个缺失部分信息的字符串，仅由大写英文字母和代表缺失的`?`号构成，要求填满其中的缺失部分，使其存在一个长度26位的连续子串，其中26个字母刚好各出现一次。
### Solution
字串长度在50000以内，大可以暴力修改。
### Code
```Cpp
void check(int x) { //判断字串中从第x位开始的子串是否满足要求
    int f[30];
    for(int i=0;i<=30;i++) f[i]=0;
    for(int i=x;i<=x+25;i++) {
        if(s[i]!='?') {
            f[s[i]-'A']++;
            if(f[s[i]-'A']>1) return;
        }
    }
    int j=0;
    for(int i=x;i<=x+25;i++) {
        if(s[i]=='?') {
            while(f[j]>0) j++;
            s[i]=(char)(j+'A');
            f[j]++;
        }
    }
    print(); //输出
}
```
***
## #C Plus and Square Root
### Description
一个等级制的小游戏，初始等级为1，有一个初始值为2的数字K。现在有两种操作，一是给数字K加上当前等级数；二是给数字K开方，并使等级上升一级。但操作二有两个要求，一个是当前的K是一个完全平方数，另一个是平方之后得到的数必须是下一等级数的倍数。现在给出一个等级数N，求使其达到N+1级的操作方法。只需输出每个等级中在对K开方之前做加法的次数。
### Solution
一道典型的数论题（结论题），理清楚题意后可以得到两个关系 ```①a[i]+ans[i]*i = a[i+1]^2 ②a[i] mod i = 0```
因为第i个答案为ans[i],因此将第一个式子变形为 ```ans[i] = (a[i+1]^2 - a[i]) / i```
这个式子说明只要能满足```a[i] mod i = 0```和```a[i+1]^2 mod i = 0```的数列a[i]都能用来构造答案数列，我们可以令```a[i] = i * (i-1)```
因此答案```ans[i] = (i+1)^2*i-i+1```, 同时要注意按照这种方式构造的数列ans[1]并不满足，因此特判后进行计算即可
### Code
```Cpp
cout << 2 << endl;
for (long long i=2;i<=n;++i){
  cout << i*(i+1)*(i+1) - i + 1 << endl; 
}
```
***
## #D Complete The Graph
### Description
给出一个无向图，其中一些边的权值被擦除了（初始值为0）。再给出起点S和终点T，要求给所有的被擦除的边赋上大于0的权值，使得S到T的最短路总权值恰好为L。
### Solution
解法非常多啦，我就把每一个解法简单提及以下   
### NO的判断方法   
>如果把所有边的权值设为1仍然大于L或者所有边都为INF仍然小于L，那就是不存在的，道理细细琢磨  
### 判断YES的办法   
#### 1.最暴力的方法。   
>我们可以对所有不确定的边的权值都进行更改，每一次都加1，更新完之后都跑一边最短路，看是否满足条件，复杂度大概是nmlogn   
#### 2.比较巧妙的办法  
>初始未确定的边的权值为1.     
我们先跑一次从终点到各个顶点的最短路，求出终点到各个点的距离，设为d[x,t]  
然后再从出发点跑一边最短路，过程中更新权值，设这边的两个端点为x/y,让他等于L-d[s,x]-d[y,t]    
于是我们在增大边权的时候，就构造了一条权值始终大于等于L的路。于是输出等于L的时候的每一条边的边权就可以了。
>还有特殊情况，就是如果这个最短路是不经过未确定的边的，那就输出NO，也就是说不用判断上面的情况了
#### 3.更为巧妙的二分
>显然将所有边值都设为1若最短路大于L则无解，所有边值设为INF最短路小于L则无解。
其他情况一定是有解的。可以想象成将所有的边一次加一，如此循环操作，最短路必定会慢慢加一必定能够到达L；
那么假设总共有x条权值不确定的边，假设先对第一条边操作，将其不断加一，每加一次跑一遍最短路，始终不能到达L则说明经过第一条边的路必定始终大于L，同理对接>下来的边也如此操作。当然这样直接写会很复杂，可以用二分来模拟这个过程，具体就是代码中的cek()函数
***
## #E Digit Tree
