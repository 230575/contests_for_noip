# The Solution

题目按CF顺序排序


## #A -Okabe and Future Gadget Laboratory

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  模拟
>
> 时间复杂度：O(N^4)
> 
> 空间复杂度：O(N^2)

### 题意
给定一个N*M的矩阵，对于矩阵中每一个不等于1的数，存在与其同一行的某数加上与其同一列的某数使其之和围该数。
### 题解
模拟其题意，暴力枚举。


## #B Okabe and Banana Trees

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  模拟
> 
> 时间复杂度：O(玄学)
>
> 空间复杂度：O(1)

### 题意
给定一条直线，找到直线上一点，使得由该点与原点组成的矩形中的所有点的权值之和最大（一点的权值为X+Y）。
### 题解
枚举可能的X，计算其Y，其权值之和为(X+1)*(Y+1)*X*Y/2。（可推导）


## #C Okabe and Boxes

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  栈
>
> 时间复杂度：O(N)
>
> 空间复杂度：O(N)

### 题意
给定一个栈，并给出一个放东西（取东西）的顺序，要求弹出物品的顺序为1....N，如果在中间某步不符合要求，请改变栈内东西的顺序使得符合题意。要求改变顺序的次数最少。输出最小次数。
### 题解
可以肯定，在每次需要排序时按降序排列时最优的；但如果每次操作时都要进行一遍排序，那超时无疑。我们假设每次操作时并不真正去实现排序，而是给他一个标记，表示之前的元素已经排好序了。我们用一个栈来模拟其过程，每次要add时就是平常操作，弹出时如果不符合要求，则表示需要排序，此时我们将栈的top赋值为0，可以理解为栈底以下的元素都是有序的。如果在某次操作是top==0，则需要从栈底以下取出一个元素，此时一定是符合要求的（因为题目保证了元素在取出前一定被放入过），于是不需要干其他操作了。



## #D Case of Fugitive

> 时间限制：  3s
>
> 空间限制：  256MB
>
> 主要算法：  贪心+二分
>
> 时间复杂度：O(NlogN)
>
> 空间复杂度：O(N)

### 题意
在一条直线上有N段陆地，分别为[li,ri]，有M座桥，长度分别为Li；桥可以连接相邻两座陆地，条件为桥的两端必须分别在两块陆地上，一座桥只能用一次。求解是否存在某种连接方式，使得N座陆地都连通，如有还要输出分配方案。
### 题解
使用贪心法则：
先将相邻两座陆地的最近和最远距离存下：br[i,1],br[i,2]，并按照其br[i,1]降序将br数组排序；对于每一座桥按其长度升序排序；
对于每个br[i,1],br[i,2]，在未使用的桥中二分出长度不大于br[i,2]的最长桥（因为对于i<j,存在br[i,1]>=br[j,1]，故每次应取最长的可行桥使得最优），标记，并将该桥删除；如果出现二分时不存在小于等于br[i,2]的桥了，则返回不可能；或在第i次取到的最长桥的长度<br[i,1]，则也返回不可能。



## #E Case of Chocolate

> 时间限制：  3s
>
> 空间限制：  256MB
>
> 主要算法：  二分+奇妙的算法
>
> 时间复杂度：O(QlogQ)
> 
> 空间复杂度：O(N)

### 题意
![the picture](https://odzkskevi.qnssl.com/d10831d2a991e7d81a0ca97c6df9a896?v=1498176242)

如图，每次操作就是在位置为(x,y)的地方，往上或往左最多能连续取几个，每次输出答案。
### 题解
![the picture](http://images2015.cnblogs.com/blog/1185618/201706/1185618-20170623193601538-718064404.png)
![the picture](http://images2015.cnblogs.com/blog/1185618/201706/1185618-20170623192604523-1318116474.png)

如图，可以轻松知道，对于一个点，如果它往上，则所有在其左边的点都与其无关（反之亦然），再考虑，其实有关的那个点就是所有在该点右边的点中最靠近该点的，我们姑且将其命名为点G，原来的点为F。如果点G和点F是同一方向的，则点F除了能延伸到G点的高度的同时，还能再延伸与点G相同的距离。如果G与F方向不同，则F显然只能延伸到G点了。
