# The Solution

题目按CF顺序排序


## #A -Greg and Array

> 时间限制：  1.5s
>
> 空间限制：  256MB
>
> 主要算法：  差分
>
> 时间复杂度：O(N)
>
> 空间复杂度：O(N)

### 题意
给定一个初始序列，给出M个操作，每个操作定义为将区间Li~Ri每个数都加上Xi；给定Q个询问，每个询问都执行的qi~qj个操作。输出最后的数列。
### 题解
差分思想：假设要在区间[l,r]加上x，则用一个空数组d，将d[l]+=x,将d[r+1]-=x，然后对d数组做一遍前缀和得到s，则s数组的[l,r]都是x了。
因为这是离线操作，故用一个数组来记录第i个操作被操作了几次（此处用差分思想实现），最后只要在统计答案时枚举每个操作，在标记时乘上该操作的使用次数即可。


## #B Greg and Graph

> 时间限制：  3s
>
> 空间限制：  256MB
>
> 主要算法：  Floyd
>
> 时间复杂度：O(N^3)
>
> 空间复杂度：O(N^2)

### 题意
有N个点，并且一个完全有向图。将N点依次删除，给并定删点的顺序；求每次删点之后剩余图中每两点之间最短距离和之和。
### 题解
如果每次删点后都跑一次Floyd，那肯定超时。既然删点难处理，就将其倒着做，转化为添点，每一次将点添进来，都作为中转点让其他点更新最短路，这样可以很巧妙地将第一维。


## #C Greg and Friends

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  DP+BFS
>
> 时间复杂度：O(N^4)
>
> 空间复杂度：O(N^2)

### 题意
有N个人要过河，每个人的体重要么为50，要么为100；船的最大载量为k，求在最少步数的情况下的方案数。
### 题解
要最少步数，自然想到BFS，而这道题一看又是DP的类型。用dp[a][b][c]表示在原岸还有a个重50的人，b个重100的人，此时船在c岸（0为原岸，1为对岸）时的方案数，vis[a][b][c]表示到当前状态的最少步数（打不到为0）。转移时枚举过河的50重的人和100重的人的个数，拿此时船在原岸的情况来说：dp[a-i][b-j][!c]+=dp[a][b][c]*C[a][i]*C[b][j];在对岸则相反。


## #D Greg and Caves

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  递推+前缀和优化

### 题意
![the picture](http://images2015.cnblogs.com/blog/1185618/201706/1185618-20170623082555210-125396151.png)
### 题解


## #E Yaroslav and Points

> 时间限制：  5s
>
> 空间限制：  256MB
>
> 主要算法：  线段树

### 题意
### 题解
